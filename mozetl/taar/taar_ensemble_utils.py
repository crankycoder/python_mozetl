# This Source Code Form is subject to the terms of the Mozilla Public
# License, v. 2.0. If a copy of the MPL was not distributed with this file,
# You can obtain one at http://mozilla.org/MPL/2.0/.
"""
This module contains code which may be 'dead' code from the
taar_ensemble.py script. Moving it here for prosterity until we are
convinced we can just delete it from the repo.
"""

import boto3
import json
import logging

logger = logging.getLogger(__name__)

def load_training_from_telemetry(spark):
    """ load some training data from telemetry given a sparkContext
    """
    sc = spark.sparkContext
    # Define the set of feature names to be used in the donor computations.
    AMO_DUMP_BUCKET = 'telemetry-parquet'
    AMO_DUMP_KEY = 'telemetry-ml/addon_recommender/addons_database.json'

    def load_amo_external_whitelist():
        """ Download and parse the AMO add-on whitelist.
        The json fetched here is generated by a weekly job that queries the AMO public API
        this whitelist is sure to exclude any Mozilla studies that are not correclty filtered
        as well as personal/unsigned/unlisted addons manually installed.
        :raises RuntimeError: the AMO whitelist file cannot be downloaded or contains
                              no valid add-ons.
        """
        final_whitelist = []
        amo_dump = {}
        try:
            # Load the most current AMO dump JSON resource.
            s3 = boto3.client('s3')
            s3_contents = s3.get_object(Bucket=AMO_DUMP_BUCKET, Key=AMO_DUMP_KEY)
            amo_dump = json.loads(s3_contents['Body'].read())
        except Exception:
            logger.exception("Failed to download from S3", extra={
                "bucket": AMO_DUMP_BUCKET,
                "key": AMO_DUMP_KEY})

        # If the load fails, we will have an empty whitelist, this may be problematic.
        for key, value in amo_dump.items():
            addon_files = value.get('current_version', {}).get('files', {})
            # If any of the addon files are web_extensions compatible, it can be recommended.
            if any([f.get("is_webextension", False) for f in addon_files]):
                final_whitelist.append(value['guid'])

        if len(final_whitelist) == 0:
            raise RuntimeError("Empty AMO whitelist detected")

        return set(final_whitelist)

    def get_initial_sample():
        """ Takes an initial sample from the longitudinal dataset
        (randomly sampled from main summary). Coarse filtering on:
        - number of installed addons
        - corrupt and generally wierd telemetry entries
        - isolating release channel
        - column selection
        """
        client_features_frame = spark.sql("SELECT * FROM longitudinal")\
                .where("active_addons IS NOT null")\
                .where("size(active_addons[0]) > 2")\
                .where("size(active_addons[0]) < 100")\
                .where("normalized_channel = 'release'")\
                .where("build IS NOT NULL AND build[0].application_name = 'Firefox'")\
                .selectExpr(\
                    "client_id as client_id",\
                    "active_addons[0] as active_addons",\
                    "geo_city[0] as geo_city",\
                    "subsession_length[0] as subsession_length",\
                    "settings[0].locale as locale",\
                    "os as os",\
                    "places_bookmarks_count[0].sum AS bookmark_count",\
                    "scalar_parent_browser_engagement_tab_open_event_count[0].value AS tab_open_count",\
                    "scalar_parent_browser_engagement_total_uri_count[0].value AS total_uri",\
                    "scalar_parent_browser_engagement_unique_domains_count[0].value AS unique_tlds")
        return client_features_frame

    def get_addons_per_client(users_df, minimum_addons_count):
        """ Extracts a DataFrame that contains one row
        for each client along with the list of active add-on GUIDs.
        """
        def is_valid_addon(guid, addon):
            """ Filter individual addons out to exclude, system addons,
            legacy addons, disabled addons, sideloaded addons.
            """
            return not (
                addon.is_system or
                addon.app_disabled or
                addon.type != "extension" or
                addon.user_disabled or
                addon.foreign_install or
                guid not in broadcast_amo_whitelist.value
            )
        # may need addiitonal whitelisting to remove shield addons

        # Create an add-ons dataset un-nesting the add-on map from each
        # user to a list of add-on GUIDs. Also filter undesired add-ons.
        return (
            users_df.rdd
            .map(lambda p: (p["client_id"],
                 [guid for guid, data in p["active_addons"].items() if is_valid_addon(guid, data)]))
            .filter(lambda p: len(p[1]) > minimum_addons_count)
            .toDF(["client_id", "addon_ids"])
        )

    # TODO: Add logging at each of these operations.
    client_features_frame = get_initial_sample()

    amo_white_list = load_amo_external_whitelist()
    broadcast_amo_whitelist = sc.broadcast(amo_white_list)

    addons_info_frame = get_addons_per_client(client_features_frame, 4)
    taar_training = addons_info_frame.join(client_features_frame, 'client_id', 'inner').drop('active_addons')

    return taar_training

